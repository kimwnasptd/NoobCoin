#!/usr/bin/env python
import sys
import subprocess
import requests
import time

PIDS_FILE = 'logs/running.pids.log'
BTS = 'http://localhost:5000'


def run(cmd, logfile):
    '''
    Run the cmd and output to the logfile, returns the ret_code, pid
    '''
    logfile = open(logfile, 'w')
    proc = subprocess.Popen(cmd.split(),
                            universal_newlines=True,
                            stdout=logfile)
    # proc.wait()

    return proc.pid


def start():
    if len(sys.argv) != 3:
        print('Usage: ./nbc start <n>')
        return

    nodes = sys.argv[2]

    pids = open(PIDS_FILE, 'w')

    # Start the bootstrapper
    cmd = 'python rest.py -p 5000 -b -n ' + nodes
    pid = run(cmd, 'logs/n0.log')

    print('Started Bootstrapper | pid: ' + str(pid))
    pids.write('bootstrapper: ' + str(pid) + '\n')

    # Make sure the bootstrap has been successfully started
    time.sleep(1)

    # All the nodes must register themselves at the Bootstrap Node
    for node in range(int(nodes))[1:]:
        port = str(5000 + node)
        pid = run('python rest.py -p ' + port, 'logs/n' + str(node) + '.log')

        # Log
        print('Started Miner | pid: ' + str(pid))
        pids.write('node' + str(node) + ': ' + str(pid) + '\n')

        # Wait for the node to register
        time.sleep(1)

    # Then the boostrap node must inform everyone about the networks structure
    resp = requests.get(BTS + '/broadcast-ring').json()
    print(resp)

    time.sleep(1)
    # The bootstrapper creates the first n initial transactions
    for n in range(int(nodes))[1:]:
        requests.post(BTS + '/create-transaction', json={
            'id': n,
            'value': 100,
        })


def stop():
    '''
    Delete all the processes that start from the 'start' step
    '''
    pids_f = open(PIDS_FILE, 'r')
    pids = [pid.split(": ")[-1] for pid in pids_f.read().split('\n')]

    for pid in pids:
        if pid != '':
            run("kill -KILL " + pid, 'stop.log')


def transaction():
    '''
    Create a new transaction from A to B with Value NBCs
    '''
    if len(sys.argv) != 5:
        print('Usage: ./nbc t <id-from> <id-to> <coins>')
        return

    src = int(sys.argv[2])
    src_addr = 'http://localhost:' + str(5000 + src) + '/create_transaction'

    dst = int(sys.argv[3])
    dst_id = 'localhost:' + str(5000 + dst)

    value = sys.argv[4]

    # POST the data to the Server's route
    requests.post(src_addr, json={'id': dst_id, 'value': value})
    print('Send: {} NBCs from [{}] -> [{}]'.
          format(value, 'localhost:' + str(5000 + src), dst_id))


def transaction_file():
    '''
    Create a new transaction from A to B with Value NBCs
    '''
    if len(sys.argv) != 4:
        print('Usage: ./nbc tf <id> <file>')
        return

    src = int(sys.argv[2])
    src_id = 'localhost:' + str(5000 + src)

    ts_file = open(sys.argv[3], 'r')
    ts = [t for t in ts_file.read().split('\n')]

    # Send each transaction
    for t in ts:
        dst = int(t.split()[0].split('id')[-1])
        dst_id = 'localhost:' + str(5000 + dst)
        val = t.split()[-1]

        requests.post('http://' + src_id, json={'id': dst_id, 'value': val})
        print('Send: {} NBCs from [{}] -> [{}]'.
              format(val, src_id, 'localhost:' + str(5000 + dst)))


if __name__ == "__main__":

    if len(sys.argv) == 1:
        print('Available commands: \n' +
              '   start <n>:   Start the Chain with <n> nodes')
        exit()

    cmd = sys.argv[1]

    if cmd == 'start':
        start()
    elif cmd == 'stop':
        stop()
    elif cmd == 't':
        transaction()
    elif cmd == 'tf':
        transaction_file()
